<!--
    Powered By nodePPT - This is probably the best web presentation tool so far!
    version: 1.4.2
    site: https://github.com/ksky521/nodePPT
    date: 
-->
<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>weex-native-render - By 李冬琳</title>
    <link rel="stylesheet" media="all" href="./css/nodeppt.css">
    <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="./css/phone.css">
    
    <link rel="stylesheet" href="./js/highlight/styles/monokai_sublime.css">
    <link rel="stylesheet" href="./css/font-awesome.css">
    
<link rel="stylesheet" href="./css/theme.moon.css">
</head>
<body>
<div class="slides">
    <slides id="container">
        <slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>Weex Native Render</h1>
<p><small>李冬琳</small></p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>上次分享遗留的几个问题</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<ul>
<li>最终的渲染是分别交给浏览器(h5)、Native实现的，所以在js层并没有内存计算。</li>
<li>不支持百分比布局，按宽度为750进行布局，最后会根据当前的屏幕大小做换算成px(value = value * window.innerWidth / 750)</li>
<li>css样式不支持继承(<a href="http://alibaba.github.io/weex/doc/references/common-style.html" target="_blank">官方支持的属性</a>大部分本来就不支持继承,color/fontSize在Native端也都不支持继承)</li>
<li>不支持overflow，要实现带滚动的布局可以使用内置的scroller组件</li>
<li>不支持z-index</li>
<li>事件、动画</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>Native Render</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>渲染流程</h2>
<ul>
<li><img src="https://gtms03.alicdn.com/tps/i3/TB1_SA4MXXXXXXGaXXXpZ8UVXXX-519-337.png" alt="Weex Render Flow "></li>
<li><a href="http://blog.csdn.net/xuguoli_beyondboy/article/details/53064155" target="_blank">参考博客</a></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>js层编译运行流程图</h2>
<h2><img src="./img/weex-html5-run.png" alt="weex-js-run"></h2>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>源代码</h2>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div id=&quot;test&quot; class=&quot;test&quot; onclick=&quot;run&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
.test { 
    background-color: #6666ff;
    width: 200;
    height: 200; 
}
&lt;/style&gt;
&lt;script&gt;
  var animation = require(&#39;@weex-module/animation&#39;)
  module.exports = {
    methods: {
      run: function () {
        var testEl = this.$el(&#39;test&#39;)
        animation.transition(testEl, {
          styles: {
            backgroundColor: &#39;#FF0000&#39;,
            transform: &#39;translate(100px, 100px)&#39;
          },
          duration: 0, //ms
          timingFunction: &#39;ease&#39;,
          &#39;transform-origin&#39;: &#39;center center&#39;,
          delay: 0 //ms
        }, function () {
          console.log(&#39;animation finished.&#39;)
        })
      }
    }
  }
&lt;/script&gt;
</code></pre>
</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<ul>
<li>会变成下面这种<a href="http://note.youdao.com/noteshare?id=134039b0899f8a3982c0b67271f42cbc" target="_blank">消息格式</a>的消息发送给native<pre><code>callNative &gt;&gt;&gt;&gt; instanceId:1, tasks:[{&quot;module&quot;:&quot;dom&quot;,&quot;method&quot;:&quot;createBody&quot;,&quot;args&quot;:[{&quot;ref&quot;:&quot;_root&quot;,
  &quot;type&quot;:&quot;div&quot;,&quot;attr&quot;:{},&quot;style&quot;:{}}]}], callback:-1
callNative &gt;&gt;&gt;&gt; instanceId:1, tasks:[{&quot;module&quot;:&quot;dom&quot;,&quot;method&quot;:&quot;addElement&quot;,&quot;args&quot;:[&quot;_root&quot;,{&quot;ref&quot;:&quot;5&quot;,
  &quot;type&quot;:&quot;div&quot;,&quot;attr&quot;:{},&quot;style&quot;:{&quot;backgroundColor&quot;:&quot;#6666ff&quot;,&quot;width&quot;:200,&quot;height&quot;:200},&quot;event&quot;:[&quot;click&quot;]},-1]}], callback:-1
callNative &gt;&gt;&gt;&gt; instanceId:1, tasks:[{&quot;module&quot;:&quot;dom&quot;,&quot;method&quot;:&quot;createFinish&quot;,&quot;args&quot;:[]}], callback:-1
</code></pre></li>
<li>通过JNI技术，v8引擎执行callNative代码会调用Java的callNative函数，然后经过一序列的调用，<br>实现布局、绑定数据、绑定事件，最终生成UI</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>事件</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<ul>
<li>在js层绑定的事件最终会被编译成<pre><code>&quot;events&quot;: {
  &quot;click&quot;: &quot;handler&quot;
},
</code></pre></li>
<li>在js端并不会绑定事件，只会存事件响应函数</li>
<li>在Native端渲染的时候，会同时绑定事件，Native端会把事件绑定在UI上,当事件触发时，Native的事件回调最终是会通过这么一句代码通知v8引擎执行相关的js代码<pre><code>mWXBridge.execJS(instanceId, namespace, function, args);
</code></pre></li>
<li>js端获取function是fireEvent，和对应的实例id，元素、事件类型，然后获取到响应这个事件的函数，并且执行这个函数</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>动画</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<ul>
<li><a href="https://alibaba.github.io/weex/cn/doc/modules/animation.html" target="_blank">动画是weex的一个内置组件</a></li>
<li><a href="https://github.com/alibaba/weex/blob/dev/android/sdk/src/main/java/com/taobao/weex/ui/animation/WXAnimationModule.java" target="_blank">Native源码</a></li>
<li>最终的实现是Native原生的动画</li>
<li>使用<pre><code>var animation = require(&#39;@weex-module/animation&#39;);
var testEl = this.$el(&#39;test&#39;);
animation.transition(testEl, {
  styles: {
  color: &#39;#FF0000&#39;,
  transform: &#39;translate(1, 1)&#39;,
  transformOrigin: &#39;center center&#39;
  },
  duration: 0, //ms
  timingFunction: &#39;ease&#39;,
  delay: 0 //ms
}, function () {
  nativeLog(&#39;animation finished.&#39;)
})
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>原理</h2>
<ul>
<li><p>在内部将模块对应的方法都变成callTasks，调用模块方法transition时，其实是在调用callTasks</p>
<pre><code>export function requireModule (moduleName) {
    const methods = nativeModules[moduleName]
    const target = {}

    for (const methodName in methods) {
      target[methodName] = (...args) =&gt; this.callTasks({
        module: moduleName,
        method: methodName,
        args: args
      })
    }

    return target
}
</code></pre></li>
<li>最终经过一序列的调用，还是通过callNative方法实现调用Native端的代码</li>
<li>Native端会根据callNative中传过来的参数识别出是内置的animation module的transition方法，然后调用相应方法执行，实现动画效果</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>动画结束的回调</h2>
<ul>
<li>在调用的时候就会把参数中的回调注册在实例上的一个callbacks数组中，并且把标记位传给Native</li>
<li>Native端动画结束后，在原生的动画结束回调事件中，调用callJS，把之前传进来的标记位作为参数传给JS，然后js端执行回调</li>
</ul>

</article></section></slide>
        

        <!-- <slide class="slide logoslide dark nobackground">
            <article class="flexbox vcenter">
                <h2 style="color: white;">Powered By nodePPT v1.4.2</h2>
            </article>
        </slide> -->
        <div class="slideTip" id="tip"></div>
    </slides>
</div>
<canvas id="drawBoard" class="draw-board" width="900" height="700"></canvas>
<div class="progress"><span id="progress"></span></div>
<div id="_buttons">
    <div class="_btn-box" id="_btn-box" style="display:none;">
        <button class="fa fa-arrow-circle-left" id="_btn-prev"></button>
        <button class="fa fa-arrow-circle-right" id="_btn-next"></button>
        <button class="fa fa-paint-brush" id="_btn-brush"></button>
        <button class="fa fa-compress" id="_btn-overview" data-toggle="fa fa-expand"></button>
    </div>
    <button class="fa fa-bars" id="_btn-bar"  data-toggle="fa fa-close"></button>
</div>
<script src="./js/mixjs/lib/mix.0.3.0.min.js"></script>
<script>
var base = location.protocol + '//' + location.host;

var path = (location.pathname + '#').split('/').filter(function(v){
    return !!v;
});
path.pop();
path = path.join('/');
MixJS.config({
    baseURL: [ base, path, 'js'].join('/')+'/'
});

</script>
<script src="./js/mixjs/lib/event/broadcast.js"></script>
<script src="./js/nodeppt.js"></script>
<script>
Slide.init({
    containerID: 'container',
    drawBoardID: 'drawBoard',
    slideClass: '.slide',
    buildClass: '.build',
    progressID: 'progress',
    transition: 'slide3',
    width: 1100,
    dir: './',
    
    //打开下面的注释就开启postMessage方式
    //访问网址127.0.0.1:8080/ppt/demo#client
    control:{
        type: 'postMessage',
        args:{
            isControl:  false
        }
    },
    
    tipID: 'tip'
});
MixJS.loadJS('highlight/highlight.pack.js',function(){
    hljs.tabReplace = '  ';
    hljs.initHighlightingOnLoad();
});
</script>
 

<!--placeholder-->
</body>
</html>
