<!--
    Powered By nodeppt - This is probably the best web presentation tool so far!
    version: 1.4.5
    site: https://github.com/ksky521/nodeppt
    date: 
-->
<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>跨平台开发 - By 李冬琳</title>
    <link rel="stylesheet" media="all" href="./css/nodeppt.css">
    <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="./css/phone.css">
    
    <link rel="stylesheet" href="./js/highlight/styles/monokai_sublime.css">
    <link rel="stylesheet" href="./css/font-awesome.css">
    
<link rel="stylesheet" href="./css/theme.moon.css">
</head>
<body>
<div class="slides">
    <slides id="container">
        <slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>主要的几种方式</h1>
<ul>
<li>代码转换</li>
<li>编译</li>
<li>虚拟机</li>
<li>Hybrid</li>
<li>React-Native Weex</li>
<li>React-Canvas</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>代码转换</h1>
<ul>
<li>Java -&gt; OC（J2OBJC）</li>
<li>OC -&gt; Java</li>
<li>某种语言（Haxe、C#） -&gt; Java、OC</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>编译</h1>
<ul>
<li>比代码转换更进一步，它直接将某个语言编译为普通平台下的二进制文件。<ul>
<li>Xamarin (c#)</li>
<li>Go</li>
</ul>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>虚拟机</h1>
<ul>
<li>如Titanium、Hyperloop、NativeScript</li>
<li>自定义一种语言、UI框架，封装各个平台的接口为统一的接口。</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>Hybrid</h1>
<ul>
<li>如PhoneGap(cordova)、Wex、APICloud的superWebView。</li>
<li>实现原理还是封装系统的WebView，性能取决于系统自带的WebView。</li>
<li>界面还是用html+css来实现，运行在WebView中。</li>
<li>交互的跨平台实现方式是针对不同平台的WebView进行封装，提供统一的js接口，供开发者调用。</li>
<li>JS与客户端通信和Hybrid的原理基本一样。</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>cordova</h1>
<img src="./img/cordova.png" alt="cordova">

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<ul>
<li>JS端使用XMLHttpRequest发起请求,每个请求生成一个叫 callbackId 的唯一标识存在js端并且传到Native<pre><code>// successCallback : 成功回调方法
// failCallback    : 失败回调方法
// server          : 所要请求的服务名字
// action          : 所要请求的服务具体操作
// actionArgs      : 请求操作所带的参数
cordova.exec(successCallback, failCallback, service, action, actionArgs);
</code></pre></li>
<li>WebView中拦截请求，根据service参数对应方法进行处理，最后把处理结果和callbackId一起传给js</li>
<li>js端根据callbackId，执行successCallback/failCallback</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>React Native</h1>
<ul>
<li>封装原生UIView成组件，前端直接使用，最终渲染成Native UI</li>
<li>js端和Native端会有一份共同的配置表，配置表里包括了所有模块和模块里方法的信息</li>
<li><img src="./img/react-native.png" alt="react-native"></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>Weex</h1>
<ul>
<li>&quot;Vue-Native&quot;</li>
<li>用html+css+js编写，然后通过transformer成js或者json，最后交由不同平台的渲染引擎进行渲染<h2>工作原理</h2>
</li>
<li><img src="./img/weex.png" alt="weex"></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>Weex架构</h1>
<ul>
<li><img src="./img/weex-2.png" alt="weex-2"></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>Weex 渲染流程</h1>
<ul>
<li>虚拟DOM.</li>
<li>构造树结构. 分析虚拟DOM JSON数据以构造渲染树(RT).</li>
<li>添加样式. 为渲染树的各个节点添加样式.</li>
<li>创建视图. 为渲染树各个节点创建Native视图.</li>
<li>绑定事件. 为Native视图绑定事件.</li>
<li>CSS布局. 使用 css-layout 来计算各个视图的布局.</li>
<li>更新视窗(Frame). 采用上一步的计算结果来更新视窗中各个视图的最终布局位置.</li>
<li>最终页面呈现.</li>
<li><img src="./img/weex-render.png" alt="weex-render"></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>react-canvas</h1>
<ul>
<li>提供标准的React组件，实现了一个渲染引擎，最终将界面绘制在Webview中的canvas中</li>
<li>性能主要依靠Webview中canvas绘制的性能</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>下一步计划</h1>
<ul>
<li>实际开发demo，对比性能fps，listview，动画，交互是否有延迟</li>
<li>阅读源码</li>
<li>复杂动画case，以及h5的动画转到native后效果消失</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>参考资源</h1>
<ul>
<li><a href="http://fex.baidu.com/blog/2015/05/cross-mobile/" target="_blank">跨平台开发</a></li>
<li><a href="http://zhenby.com/blog/2013/05/16/cordova-for-ios/" target="_blank">cordova</a></li>
<li><a href="http://blog.cnbang.net/tech/2698/" target="_blank">react-native</a></li>
<li><a href="http://www.infoq.com/cn/articles/taobao-mobile-weex" target="_blank">weex</a></li>
<li><a href="https://yq.aliyun.com/articles/57995" target="_blank">weex</a></li>
</ul>

</article></section></slide>
        

        <!-- <slide class="slide logoslide dark nobackground">
            <article class="flexbox vcenter">
                <h2 style="color: white;">Powered By nodeppt v1.4.5</h2>
            </article>
        </slide> -->
        <div class="slideTip" id="tip"></div>
    </slides>
</div>
<canvas id="drawBoard" class="draw-board" width="900" height="700"></canvas>
<div class="progress"><span id="progress"></span></div>
<div id="_buttons">
    <div class="_btn-box" id="_btn-box" style="display:none;">
        <button class="fa fa-arrow-circle-left" id="_btn-prev"></button>
        <button class="fa fa-arrow-circle-right" id="_btn-next"></button>
        <button class="fa fa-paint-brush" id="_btn-brush"></button>
        <button class="fa fa-compress" id="_btn-overview" data-toggle="fa fa-expand"></button>
    </div>
    <button class="fa fa-bars" id="_btn-bar"  data-toggle="fa fa-close"></button>
</div>
<script src="./js/mixjs/lib/mix.0.3.0.min.js"></script>
<script>
    var ASSET_RELATIVE_DIR = ".";
</script>
<script>
var base = location.protocol + '//' + location.host;

var path = (location.pathname + '#').split('/').filter(function(v){
    return !!v;
});
path.pop();
path = path.join('/');
if (typeof ASSET_RELATIVE_DIR === 'string') {
    path = path + '/' + ASSET_RELATIVE_DIR;
}
MixJS.config({
    baseURL: [ base, path, 'js'].join('/')+'/'
});

</script>
<script src="./js/mixjs/lib/event/broadcast.js"></script>
<script src="./js/nodeppt.js"></script>
<script>
Slide.init({
    containerID: 'container',
    drawBoardID: 'drawBoard',
    slideClass: '.slide',
    buildClass: '.build',
    progressID: 'progress',
    transition: 'slide3',
    width: 1100,
    dir: './',
    
    //打开下面的注释就开启postMessage方式
    //访问网址127.0.0.1:8080/ppt/demo#client
    control:{
        type: 'postMessage',
        args:{
            isControl:  false
        }
    },
    
    tipID: 'tip'
});
MixJS.loadJS('highlight/highlight.pack.js',function(){
    hljs.tabReplace = '  ';
    hljs.initHighlightingOnLoad();
});
</script>
 

<!--placeholder-->
</body>
</html>
