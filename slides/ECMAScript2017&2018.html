<!--
    Powered By nodeppt - This is probably the best web presentation tool so far!
    version: 1.4.5
    site: https://github.com/ksky521/nodeppt
    date: 
-->
<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ECMAScript2017&amp;2018 - By 李冬琳</title>
    <link rel="stylesheet" media="all" href="./css/nodeppt.css">
    <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="./css/phone.css">
    
    <link rel="stylesheet" href="./js/highlight/styles/monokai_sublime.css">
    <link rel="stylesheet" href="./css/font-awesome.css">
    
<link rel="stylesheet" href="./css/theme.moon.css">
</head>
<body>
<div class="slides">
    <slides id="container">
        <slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ECMAScript规范及ECMAScript2017&amp;2018</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>主要内容</h1>
<ul>
<li>ECMAScript规范及其制定流程</li>
<li>ES2017&amp;ES2018</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ECMAScript规范及其制定流程</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ECMAScript规范是什么？</h1>
<ul>
<li>ECMAScript<ul>
<li>是一种由Ecma国际通过ECMA-262标准化的脚本程序设计语言，它的具体实现有JavaScript、MS的JScript、Adobe 的ActionScript</li>
</ul>
</li>
<li>Ecma国际<ul>
<li>Ecma国际是一个制定通信技术、消费电子等领域相关标准的一个组织。其会员目前有Google、HP、Hitachi、IBM、Intel、Konica Minolta、MircroSoft、Paypal、Yahoo等.</li>
</ul>
</li>
<li>ECMA-262<ul>
<li>ECMA在1997年发布的262号标准。</li>
</ul>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ECMAScript的历史</h1>
<ul>
<li>1995年，Netscape的Brendan Eich发明了JavaScript语言</li>
<li>1996年Netscape将JavaScript提交给ECMA</li>
<li>1997年6月，ECMAScript 1.0</li>
<li>1998年6月，ECMAScript 2.0</li>
<li>1999年12月，ECMAScript 3.0</li>
<li>2009年12月，ECMAScript 5.0</li>
<li>2011年6月，ECMAScript 5.1</li>
<li>2015年6月，ECMAScript 2015</li>
<li>...</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ECMAScript规范如何制定?</h1>
<ul>
<li>ECMAScript规范由Ecma国际的TC39委员会制定</li>
<li>从ECMAScript2016(ES7)开始是每年发布一个版本，并且成文标准要从事实标准中诞生，实现先于标准存在</li>
<li>任何人都可以去<a href="https://github.com/tc39/ecma262/pulls" target="_blank">ecma262的github</a>以提PR的方式提出提案</li>
<li>TC39委员会每两月开一次会，讨论各个阶段的提案能否进入下一阶段</li>
<li>每个提案一共要经过<a href="https://tc39.github.io/process-document/" target="_blank">5个阶段</a>，到达stage4的提案才会写入当年要发布的规范</li>
<li>每年6月份会开General Assembly，表决是否通过当年的ECMA-262标准。</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<p>每个提案要经过的五个阶段的官方说明
<img src="./img/ECMA/stages.png" alt="stages"></p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>5个阶段说明</h1>
<ul>
<li>stage0(Strawman)，只要注册会TC39的会员，就可以提交</li>
<li>stage1(Proposal)，提供demos/polyfills。说明TC39委员会愿意考虑这提议</li>
<li>stage2(Draft), 完善的说明，必须包含2个实验性的具体实现，其中一个可以是用转译器实现的，例如Babel</li>
<li>stage3(Candidate)，规范文档，评审人和ECMAScript的编辑要在规范上签字，至少要有两个符合规范的具体实现</li>
<li>stage4(Finished)，完成阶段，必须有2个实现通过<a href="https://github.com/tc39/test262" target="_blank">test262</a>测试，ECMAScript的编辑必须规范上的签字</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ECMAScript2017 总体介绍</h1>
<ul>
<li>共27章+7个附录，共880页</li>
<li>1-5章主要是讲规范本身的历史、引用、符号约定等内容</li>
<li>6-9章分别是数据类型、抽象操作、执行上下文、对象的内部方法</li>
<li>10-16章是对ECMAScript的语法定义，比如表达式、语句、函数、类等</li>
<li>17-26章主要是ECMAScript标准库的定义，就是比如全局对象、数字、日期、Proxy、Reflect等标准对象的定义</li>
<li>27章是内存模型</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ES2017&amp;ES2018</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>ES2017</h1>
<ul>
<li>今年6月27号在General Assembly上表决通过，包含的<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" target="_blank">新特性</a>主要有以下几个：<ul>
<li>Object.values/Object.entries</li>
<li>String padding</li>
<li>Object.getOwnPropertyDescriptors</li>
<li>Trailing commas in function parameter lists and calls</li>
<li>Async Functions</li>
<li>Shared memory and atomics</li>
</ul>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>Object新增两个枚举方法</h2>
<ul>
<li><p>Object.values</p>
<pre><code>const obj = { x: &#39;xxx&#39;, y: 1 };
Object.values(obj); // [&#39;xxx&#39;, 1]

const obj = [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;]; // same as { 0: &#39;e&#39;, 1: &#39;s&#39;, 2: &#39;8&#39; };
Object.values(obj); // [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;]
</code></pre></li>
<li><p>Object.entries</p>
<pre><code>const obj = { x: &#39;xxx&#39;, y: 1 };
Object.entries(obj); // [[&#39;x&#39;, &#39;xxx&#39;], [&#39;y&#39;, 1]]

const obj = [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;];
Object.entries(obj); // [[&#39;0&#39;, &#39;e&#39;], [&#39;1&#39;, &#39;s&#39;], [&#39;2&#39;, &#39;
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>2 String padding</h2>
<ul>
<li>内置String填充函数<ul>
<li>padStart<pre><code>&#39;es8&#39;.padStart(2);          // &#39;es8&#39;
&#39;es8&#39;.padStart(5);          // &#39;  es8&#39;
&#39;es8&#39;.padStart(6, &#39;woof&#39;);  // &#39;wooes8&#39;
&#39;es8&#39;.padStart(14, &#39;wow&#39;);  // &#39;wowwowwowwoes8&#39;
</code></pre></li>
<li>padEnd<pre><code>&#39;es8&#39;.padEnd(2);          // &#39;es8&#39;
&#39;es8&#39;.padEnd(5);          // &#39;es8  &#39;
&#39;es8&#39;.padEnd(6, &#39;woof&#39;);  // &#39;es8woo&#39;
&#39;es8&#39;.padEnd(14, &#39;wow&#39;);  // &#39;es8wowwowwowwo&#39;
</code></pre></li>
</ul>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>3 Object.getOwnPropertyDescriptors</h2>
<ul>
<li>返回对象自身所有属性的属性描述符<pre><code>const obj = { 
  get es7() { return 777; },
  get es8() { return 888; }
};
Object.getOwnPropertyDescriptors(obj);
  // {
  //   es7: {
  //     configurable: true,
  //     enumerable: true,
  //     get: function es7(){}, //the getter function
  //     set: undefined
  //   },
  //   es8: {
  //     configurable: true,
  //     enumerable: true,
  //     get: function es8(){}, //the getter function
  //     set: undefined
  //   }
  // }
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>4 Trailing commas in function parameter lists and calls</h2>
<ul>
<li>函数声明和函数调用时允许参数尾部添加逗号<pre><code>function es8(var1, var2, var3,) {
// ...
}
es8(10, 20, 30,);
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>5 Async Function</h2>
<ul>
<li>异步编程解决方案<pre><code>function fetchTextByPromise() {
  return new Promise(resolve =&gt; { 
      setTimeout(() =&gt; { 
      resolve(&quot;es8&quot;);
      }, 2000);
  });
}
async function sayHello() { 
  const externalFetchedText = await fetchTextByPromise();
  console.log(`Hello, ${externalFetchedText}`); // Hello, es8
}
sayHello(); // Hello es8
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>6 Shared memory and atomics</h2>
<ul>
<li>结合Web Worker，使用SharedArrayBuffer在不同线程间共享内存，通过Atomicsj解决多线程对共享内存的的竞态问题。<pre><code>// main.js
  const worker = new Worker(&#39;worker.js&#39;);
  // To be shared
  const sharedBuffer = new SharedArrayBuffer( // (A)
      10 * Int32Array.BYTES_PER_ELEMENT); // 10 elements
  // Share sharedBuffer with the worker
  worker.postMessage({sharedBuffer}); // clone
  // Local only
  const sharedArray = new Int32Array(sharedBuffer); // (B)
  // worker.js
  self.addEventListener(&#39;message&#39;, function (event) {
      const {sharedBuffer} = event.data;
      const sharedArray = new Int32Array(sharedBuffer); // (A)
      // ···
  });
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vleft">
<h1>ES2018</h1>
<ul>
<li><p>stage4目前只有一个</p>
<ul>
<li><a href="https://github.com/tc39/proposal-template-literal-revision" target="_blank">Lifting template literal restriction</a></li>
</ul>
</li>
<li><p>stage3有<a href="https://github.com/tc39/proposals/blob/master/README.md" target="_blank">14个</a></p>
<ul>
<li><a href="http://tc39.github.io/Function-prototype-toString-revision/" target="_blank">Function.prototype.toString revision</a></li>
<li><a href="https://github.com/tc39/proposal-promise-finally" target="_blank">promise-finally</a></li>
<li><a href="https://github.com/tc39/proposal-optional-catch-binding" target="_blank">Optional catch binding</a></li>
<li><a href="https://github.com/tc39/proposal-class-fields" target="_blank">class fields</a></li>
<li><a href="https://github.com/tc39/proposal-dynamic-import" target="_blank">import()</a></li>
<li><a href="https://github.com/tc39/proposal-global" target="_blank">global</a></li>
</ul>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<ul>
<li><a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank">Rest/Spread Properties</a></li></li>
<li><a href="https://github.com/tc39/proposal-async-iteration" target="_blank">Asynchronous Iteration</a></li>
<li><a href="https://github.com/tc39/proposal-regexp-lookbehind" target="_blank">RegExp Lookbehind Assertions</a></li>
<li><a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank">RegExp Unicode Property Escapes</a></li>
<li><a href="https://github.com/tc39/proposal-regexp-named-groups" target="_blank">RegExp named capture groups</a></li>
<li><a href="https://github.com/tc39/proposal-regexp-dotall-flag" target="_blank">s (dotAll) flag for regular expressions</a></li>
<li><a href="https://github.com/tc39/proposal-regexp-legacy-features" target="_blank">Legacy RegExp features in JavaScript</a></li>
<li><a href="https://github.com/tc39/proposal-bigint" target="_blank">BigInt</a></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>stage 4</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>Template Literal Revision</h1>
<ul>
<li>现在规范中，对于模板字符串有限制，会对\x，\u开头的字符串进行转义<pre><code>function latex(strings) {...}
let document = latex`
  \newcommand{\unicode}{\textbf{Unicode!}} // 报错
  \newcommand{\xerxes}{\textbf{King!}} // 报错
`
</code></pre></li>
<li>该提案就是放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。<pre><code>function tag(strs) {
    strs[0] === undefined
    strs.raw[0] === &quot;\\unicode and \\u{55}&quot;;
}
tag`\unicode and \u{55}`
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>stage3</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>1 Function.prototype.toString</h1>
<ul>
<li>以前规范规定的很模糊，导致各引擎实现的不一致。比如对换行空格的处理、内置函数和自定义函数的返回</li>
<li>这个提案就是明确、具体的规定这个方法的针对不同的函数应该返回什么。<ul>
<li>内置函数、宿主函数、绑定函数一律返回&quot;function () { [native code] }&quot;</li>
<li>通过ECMAScript定义的，一字不落的返回和源代码一样的文本</li>
<li>通过Function等构造函数动态创建的，合成一个源代码返回，针对不同的情况，规定了按何种格式返回</li>
<li>其余情况返回TypeError</li>
</ul>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>2 Promise.prototype.finally</h2>
<ul>
<li><p>Promise原生提供finally方法</p>
<pre><code>Promise.resolve(2)
.then(() =&gt; {}, () =&gt; {})
.finally(function () {

})
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>3 Optional catch binding</h2>
<ul>
<li><p>目前的规范规定try{}catch(e){}的e参数不可省略。但是这个参数又经常不用。这个提案就提出让这个参数变成是可选的。</p>
<pre><code>try{

}catch(){
  // 可不写参数了
}
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>4 global</h2>
<ul>
<li>增加一个名为global的全局对象，在浏览器、nodejs、Web Workers通用的全局对象</li>
</ul>
<h2>5 import(specifier)</h2>
<ul>
<li>支持动态加载模块，返回一个Promise<pre><code>if (isLegacyPlatform()) {
  import(`messages_${getLocale()}.js)
  .then(myModule =&gt; {
      console.log(myModule.default);
  });
}
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>6 Rest/Spread Properties</h2>
<ul>
<li>对象也支持原来数组的展开运算符和函数形参的剩余参数语法<pre><code>const obj = {foo: 1, bar: 2, baz: 3};
const {foo, ...rest} = obj;
</code></pre><pre><code>const obj = {foo: 1, bar: 2, baz: 3};
console.log({...obj, qux: 4})
//{foo: 1, bar: 2, baz: 3, qux: 4 }
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>7 class-fields</h2>
<ul>
<li><p>class定义新增公共字段和私有字段</p>
<pre><code>class Counter extends HTMLElement {
#x = 0; //私有字段
y = 1;
a () {

}
}
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>8 async-iteration</h2>
<ul>
<li><p>新增异步迭代器，针对异步数据迭代</p>
<pre><code>const { value, done } = syncIterator.next();

asyncIterator.next().then(({ value, done }) =&gt; /* ... */);

for await (const line of readLines(filePath)) {
  console.log(line);
}
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>9 RegExp Lookbehind Assertions</h2>
<ul>
<li><p>正则表达式以前只有先行断言，现在新增正向后行断言(?&lt;=...)和负向后行断言(?&lt;!...)</p>
<pre><code>/(?&lt;=\$)\d+(\.\d*)?/.test(&#39;$10.53&#39;) // true
/(?&lt;=\$)\d+(\.\d*)?/.test(&#39;&amp;10.53&#39;) // false

/(?&lt;!\$)\d+(\.\d*)?/.test(&#39;$10.53&#39;) // false
/(?&lt;!\$)\d+(\.\d*)?/.test(&#39;&amp;10.53&#39;) // true
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>10 Unicode property escapes in regular expressions</h2>
<ul>
<li><p>正则表达式新增一种方式</p>
<pre><code class="\p{UnicodePropertyName=UnicodePropertyValue},\P{UnicodePropertyValue}```，可以实现对某一类Unicode字符的识别，而不是写一串的\u1232...">```
const regex = /^\p{Decimal_Number}+$/u;
regex.test(&#39;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#39;);
// → true

const regex = /\p{Emoji_Modifier_Base}$/u;
regex.test(&#39;⌚&#39;);
// → true
</code></pre>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>11 RegExp named capture groups</h2>
<ul>
<li>正则表达式新增命名捕获分组语法<code>(?&lt;name&gt;...)</code><pre><code>let {groups: {one, two}} = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec(&#39;foo:bar&#39;);
console.log(`one: ${one}, two: ${two}`);  // prints one: foo, two: bar
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>12 regexp-dotall-flag</h2>
<ul>
<li>以前正则里的<code>.</code>不能匹配<code>\n \r</code>等换行符，新增<code>s</code>flag，支持单行模式，从而让<code>.</code>能匹配换行符<pre><code>/./s.test(&#39;\n&#39;) // true
</code></pre></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>13 regexp-legacy-features</h2>
<ul>
<li>将很多浏览器已经实现了的，但是没有写入规范的RegExp构造函数上的属性，比如RegExp.$1-9、RegExp.input等写入规范，并且规定了这些属性的特性。<a href="https://github.com/tc39/proposal-regexp-legacy-features/blob/master/changes.md" target="_blank">具体改动</a></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>14 BigInt</h2>
<ul>
<li>新增一个数值类型：BigInt，用来表示大于2^53和小于-2^53的整数。<pre><code>typeof 123n === &#39;bigint&#39;
</code></pre></li>
<li>Number和BigInt不能互转</li>
<li>重载了+ / 等运算符</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>THX</h1>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<ul>
<li><a href="http://www.ecma-international.org/" target="_blank">ECMA国际</a></li>
<li><a href="https://github.com/rwaldron/tc39-notes" target="_blank">tc39会议纪要</a></li>
<li><a href="https://github.com/tc39/proposals/blob/master/README.md" target="_blank">正在进行中的各个提案的状态</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/6.0/index.html" target="_blank">ECMAScript2017</a></li>
<li><a href="https://www.w3.org/html/ig/zh/wiki/ES5" target="_blank">ES5中文</a></li>
<li><a href="http://2ality.com/2015/11/tc39-process.html" target="_blank">Dr.Axel Rauschmayer</a></li>
<li><a href="http://www.cnblogs.com/ziyunfei/p/5712519.html" target="_blank">紫云飞</a></li>
</ul>

</article></section></slide>
        

        <!-- <slide class="slide logoslide dark nobackground">
            <article class="flexbox vcenter">
                <h2 style="color: white;">Powered By nodeppt v1.4.5</h2>
            </article>
        </slide> -->
        <div class="slideTip" id="tip"></div>
    </slides>
</div>
<canvas id="drawBoard" class="draw-board" width="900" height="700"></canvas>
<div class="progress"><span id="progress"></span></div>
<div id="_buttons">
    <div class="_btn-box" id="_btn-box" style="display:none;">
        <button class="fa fa-arrow-circle-left" id="_btn-prev"></button>
        <button class="fa fa-arrow-circle-right" id="_btn-next"></button>
        <button class="fa fa-paint-brush" id="_btn-brush"></button>
        <button class="fa fa-compress" id="_btn-overview" data-toggle="fa fa-expand"></button>
    </div>
    <button class="fa fa-bars" id="_btn-bar"  data-toggle="fa fa-close"></button>
</div>
<script src="./js/mixjs/lib/mix.0.3.0.min.js"></script>
<script>
    var ASSET_RELATIVE_DIR = ".";
</script>
<script>
var base = location.protocol + '//' + location.host;

var path = (location.pathname + '#').split('/').filter(function(v){
    return !!v;
});
path.pop();
path = path.join('/');
if (typeof ASSET_RELATIVE_DIR === 'string') {
    path = path + '/' + ASSET_RELATIVE_DIR;
}
MixJS.config({
    baseURL: [ base, path, 'js'].join('/')+'/'
});

</script>
<script src="./js/mixjs/lib/event/broadcast.js"></script>
<script src="./js/nodeppt.js"></script>
<script>
Slide.init({
    containerID: 'container',
    drawBoardID: 'drawBoard',
    slideClass: '.slide',
    buildClass: '.build',
    progressID: 'progress',
    transition: 'slide3',
    width: 1100,
    dir: './',
    
    //打开下面的注释就开启postMessage方式
    //访问网址127.0.0.1:8080/ppt/demo#client
    control:{
        type: 'postMessage',
        args:{
            isControl:  false
        }
    },
    
    tipID: 'tip'
});
MixJS.loadJS('highlight/highlight.pack.js',function(){
    hljs.tabReplace = '  ';
    hljs.initHighlightingOnLoad();
});
</script>
 

<!--placeholder-->
</body>
</html>
